name: CI/CD Pipeline

on:
  push:
    branches: [ '**' ]
  pull_request_target:
    types: [closed]
    branches: [main]
  workflow_dispatch:
    inputs:
      version:
        description: 'Package version to publish (optional - will use current if not specified)'
        required: false
        type: string
      skip_tests:
        description: 'Skip running tests (use with caution!)'
        required: false
        type: boolean
        default: false

# Cancel in-progress workflows when a new commit is pushed
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}-${{ github.event_name == 'pull_request_target' && github.event.pull_request.number || 'push' }}
  cancel-in-progress: ${{ github.event_name != 'workflow_dispatch' }}

env:
  PYTHON_VERSION: "3.11"

jobs:
  test:
    name: Test Suite
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        python-version: ["3.9", "3.10", "3.11", "3.12"]

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v5
      with:
        python-version: ${{ matrix.python-version }}

    - name: Cache pip dependencies
      uses: actions/cache@v4
      with:
        path: ~/.cache/pip
        key: pip-${{ runner.os }}-${{ matrix.python-version }}-${{ hashFiles('**/pyproject.toml', '**/requirements*.txt') }}
        restore-keys: |
          pip-${{ runner.os }}-${{ matrix.python-version }}-

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -e ".[dev]"
        pip install build twine

    - name: Run tests
      run: |
        pytest tests/ -v --tb=short --junitxml=test-results-${{ matrix.python-version }}.xml -m "not slow"

    - name: Upload test results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: test-results-${{ matrix.python-version }}
        path: test-results-${{ matrix.python-version }}.xml
        retention-days: 7

  lint:
    name: Code Quality
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: Cache pre-commit
      uses: actions/cache@v4
      with:
        path: ~/.cache/pre-commit
        key: pre-commit-${{ runner.os }}-${{ hashFiles('.pre-commit-config.yaml') }}

    - name: Install pre-commit
      run: |
        python -m pip install --upgrade pip
        pip install pre-commit

    - name: Run pre-commit hooks
      run: pre-commit run --all-files

  check-package-label:
    name: Check Package Label / Manual Trigger
    runs-on: ubuntu-latest
    if: (github.event_name == 'pull_request_target' && github.event.pull_request.merged == true) || github.event_name == 'workflow_dispatch'
    outputs:
      has_package_label: ${{ steps.check_label.outputs.has_label || 'true' }}
      pr_number: ${{ steps.check_label.outputs.pr_number || '0' }}
      is_manual: ${{ github.event_name == 'workflow_dispatch' }}
      manual_version: ${{ steps.manual_version.outputs.version || '' }}

    steps:
    - name: Check for Package label (PR)
      id: check_label
      if: github.event_name == 'pull_request_target'
      uses: actions/github-script@v7
      with:
        script: |
          const labels = context.payload.pull_request.labels.map(label => label.name);
          const has_package_label = labels.includes('package');
          const pr_number = context.payload.pull_request.number;

          console.log('PR Labels:', labels);
          console.log('Has package label:', has_package_label);

          core.setOutput('has_label', has_package_label);
          core.setOutput('pr_number', pr_number);

          if (!has_package_label) {
            console.log('⏭️ Skipping package deployment - no Package label found');
          } else {
            console.log('✅ Package label found - proceeding with deployment pipeline');
          }

    - name: Get manual version
      id: manual_version
      if: github.event_name == 'workflow_dispatch' && github.event.inputs.version != ''
      run: |
        echo "version=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
        echo "✅ Using manually specified version: ${{ github.event.inputs.version }}"

  version-check:
    name: Version Check
    runs-on: ubuntu-latest
    needs: [test, lint, check-package-label]
    if: needs.check-package-label.outputs.has_package_label == 'true'
    outputs:
      version: ${{ steps.get_version.outputs.version }}
      version_changed: ${{ steps.check_version.outputs.changed || 'true' }}

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        ref: ${{ github.event.pull_request.merge_commit_sha || github.sha }}
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: Get current version
      id: get_version
      run: |
        python << 'EOF'
        import re
        import sys
        import os

        with open('pyproject.toml', 'r') as f:
          content = f.read()
        match = re.search(r'version = "([^"]+)"', content)

        if not match:
          print("❌ ERROR: Could not find version in pyproject.toml")
          sys.exit(1)

        version = match.group(1)
        with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
          f.write(f"version={version}\n")
        print(f"Current version: {version}")
        EOF

    - name: Check version change against PR base
      id: check_version
      if: github.event_name == 'pull_request_target'
      env:
        BASE_SHA: ${{ github.event.pull_request.base.sha }}
        MERGE_SHA: ${{ github.event.pull_request.merge_commit_sha }}
      run: |
        python << 'EOF'
        import re
        import subprocess
        import sys
        import os
        import time
        from subprocess import TimeoutExpired

        def get_version_from_commit(commit_sha, commit_name, retries=3):
          for attempt in range(retries):
            try:
              result = subprocess.run(['git', 'show', f'{commit_sha}:pyproject.toml'],
                                    capture_output=True, text=True, check=True, timeout=30)
              content = result.stdout
              match = re.search(r'version = "([^"]+)"', content)

              if not match:
                print(f"❌ ERROR: Could not find version in {commit_name} ({commit_sha[:8]})")
                if attempt == retries - 1:
                  sys.exit(1)
                continue

              version = match.group(1)
              print(f"Version from {commit_name} ({commit_sha[:8]}): {version}")
              return version
            except subprocess.CalledProcessError as e:
              print(f"❌ ERROR: Could not retrieve {commit_name} ({commit_sha[:8]}): {e}")
              if attempt == retries - 1:
                sys.exit(1)
              time.sleep(2 ** attempt)  # Exponential backoff
            except subprocess.TimeoutExpired:
              print(f"⏱️ Timeout retrieving {commit_name}, retrying...")
              if attempt == retries - 1:
                print("❌ ERROR: Timeout after multiple attempts")
                sys.exit(1)
              time.sleep(2 ** attempt)

        # Get commit SHAs from environment
        base_sha = os.environ.get('BASE_SHA')
        merge_sha = os.environ.get('MERGE_SHA')

        if not base_sha or not merge_sha:
          print("❌ ERROR: Missing commit SHAs from GitHub event payload")
          sys.exit(1)

        print(f"PR base commit (main before merge): {base_sha}")
        print(f"Merge commit (after PR merge): {merge_sha}")

        # Get versions from both commits
        base_version = get_version_from_commit(base_sha, "PR base")
        merge_version = get_version_from_commit(merge_sha, "merge commit")

        changed = base_version != merge_version

        with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
          f.write(f"changed={'true' if changed else 'false'}\n")

        if changed:
          print(f"✅ Version changed from {base_version} → {merge_version}")
        else:
          print(f"❌ Version unchanged ({base_version}) - please bump version in pyproject.toml")
          sys.exit(1)
        EOF

  build:
    name: Build Python Package
    runs-on: ubuntu-latest
    needs: [test, lint, version-check]

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: Install build dependencies
      run: |
        python -m pip install --upgrade pip
        pip install build twine

    - name: Build package (wheel and sdist)
      run: python -m build

    - name: Verify built packages
      run: twine check dist/*

    - name: Upload built packages
      uses: actions/upload-artifact@v4
      with:
        name: python-package-distributions
        path: dist/
        retention-days: 7
  verify_package:
    name: Verify Package Installation
    runs-on: ubuntu-latest
    needs: [build]

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download build artifacts
      uses: actions/download-artifact@v4
      with:
        name: python-package-distributions
        path: dist/

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: List built packages
      run: |
        echo "Built packages:"
        ls -la dist/
        echo ""
        echo "Package summary:"
        echo "Source distributions: $(ls dist/*.tar.gz 2>/dev/null | wc -l)"
        echo "Wheels: $(ls dist/*.whl 2>/dev/null | wc -l)"

    - name: Test wheel installation
      run: |
        # Test wheel installation
        python -m venv test_wheel_env
        source test_wheel_env/bin/activate
        pip install --upgrade pip
        pip install dist/*.whl

        # Run minimal confopt test
        python -c "
        import numpy as np
        from confopt.tuning import ConformalTuner
        from confopt.wrapping import IntRange, FloatRange

        # Minimal synthetic test
        def simple_objective(configuration):
            # Simple quadratic function with noise
            x, y = configuration['x'], configuration['y']
            return (x - 2)**2 + (y - 3)**2 + np.random.normal(0, 0.1)

        search_space = {
            'x': FloatRange(min_value=0.0, max_value=5.0),
            'y': FloatRange(min_value=0.0, max_value=5.0)
        }

        tuner = ConformalTuner(
            objective_function=simple_objective,
            search_space=search_space,
            minimize=True
        )

        tuner.tune(max_searches=50, n_random_searches=15, verbose=False)
        best_params = tuner.get_best_params()
        best_value = tuner.get_best_value()

        print(f'Wheel installation and basic functionality test successful!')
        print(f'Best params: {best_params}')
        print(f'Best value: {best_value:.4f}')
        "

        deactivate
        rm -rf test_wheel_env

    - name: Test source distribution installation
      run: |
        # Test source installation
        python -m venv test_sdist_env
        source test_sdist_env/bin/activate
        pip install --upgrade pip
        pip install dist/*.tar.gz

        # Run minimal confopt test
        python -c "
        import numpy as np
        from confopt.tuning import ConformalTuner
        from confopt.wrapping import IntRange, FloatRange

        # Minimal synthetic test
        def simple_objective(configuration):
            # Simple quadratic function with noise
            x, y = configuration['x'], configuration['y']
            return (x - 2)**2 + (y - 3)**2 + np.random.normal(0, 0.1)

        search_space = {
            'x': FloatRange(min_value=0.0, max_value=5.0),
            'y': FloatRange(min_value=0.0, max_value=5.0)
        }

        tuner = ConformalTuner(
            objective_function=simple_objective,
            search_space=search_space,
            minimize=True
        )

        tuner.tune(max_searches=50, n_random_searches=15, verbose=False)
        best_params = tuner.get_best_params()
        best_value = tuner.get_best_value()

        print(f'Source distribution installation and basic functionality test successful!')
        print(f'Best params: {best_params}')
        print(f'Best value: {best_value:.4f}')
        "

        deactivate
        rm -rf test_sdist_env
  test-publish:
    name: Publish to TestPyPI
    runs-on: ubuntu-latest
    needs: [verify_package]

    steps:
    - name: Download build artifacts
      uses: actions/download-artifact@v4
      with:
        name: python-package-distributions
        path: dist/

    - name: Publish to TestPyPI
      uses: pypa/gh-action-pypi-publish@release/v1
      with:
        repository-url: https://test.pypi.org/legacy/
        password: ${{ secrets.TEST_PYPI_API_TOKEN }}
        skip-existing: true  # Skip if version already exists

    - name: Wait for TestPyPI propagation
      run: |
        VERSION=${{ needs.version-check.outputs.version }}

        # Wait for TestPyPI to be available with exponential backoff
        echo "Waiting for TestPyPI propagation..."
        for i in {1..12}; do  # Up to 2 minutes (1+2+4+8+16+32+64+128+256+512+1024+2048 ms)
          if pip index versions --index-url https://test.pypi.org/simple/ confopt | grep -q "Available versions:"; then
            if pip index versions --index-url https://test.pypi.org/simple/ confopt | grep -q "$VERSION"; then
              echo "✅ TestPyPI package $VERSION is now available"
              break
            fi
          fi

          if [ $i -eq 12 ]; then
            echo "❌ ERROR: Package not found on TestPyPI after 2 minutes"
            exit 1
          fi

          sleep_time=$((2 ** (i-1) / 1000))
          echo "⏱️  Waiting ${sleep_time}s for TestPyPI propagation (attempt $i/12)..."
          sleep $sleep_time
        done
  verify-testpypi:
    name: Verify TestPyPI Installation
    runs-on: ubuntu-latest
    needs: [test-publish]

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: Get version
      id: get_version
      run: |
        # Get version from pyproject.toml
        python << 'EOF'
        import re
        import sys
        import os

        with open('pyproject.toml', 'r') as f:
            content = f.read()
        match = re.search(r'version = "([^"]+)"', content)

        if not match:
            print("ERROR: Could not find version in pyproject.toml")
            sys.exit(1)

        version = match.group(1)
        with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
            f.write(f"version={version}\n")
        print(f"Current version: {version}")
        EOF

    - name: Test installation scenarios from TestPyPI
      run: |
        VERSION=${{ steps.get_version.outputs.version }}

        # Test wheel installation from TestPyPI
        echo "Test: Wheel installation from TestPyPI..."
        python -m venv test_wheel_env
        source test_wheel_env/bin/activate
        pip install --upgrade pip

        pip install --index-url https://test.pypi.org/simple/ --extra-index-url https://pypi.org/simple/ confopt==$VERSION

        python -c "
        import numpy as np
        from confopt.tuning import ConformalTuner
        from confopt.wrapping import IntRange, FloatRange

        # Minimal synthetic test
        def simple_objective(configuration):
            # Simple quadratic function with noise
            x, y = configuration['x'], configuration['y']
            return (x - 2)**2 + (y - 3)**2 + np.random.normal(0, 0.1)

        search_space = {
            'x': FloatRange(min_value=0.0, max_value=5.0),
            'y': FloatRange(min_value=0.0, max_value=5.0)
        }

        tuner = ConformalTuner(
            objective_function=simple_objective,
            search_space=search_space,
            minimize=True
        )

        tuner.tune(max_searches=50, n_random_searches=15, verbose=False)
        best_params = tuner.get_best_params()
        best_value = tuner.get_best_value()

        print('TestPyPI wheel installation and functionality test successful!')
        print(f'Best params: {best_params}')
        print(f'Best value: {best_value:.4f}')
        "

        deactivate
        rm -rf test_wheel_env



        # Test source installation from TestPyPI
        echo "Test: Source installation from TestPyPI..."
        python -m venv test_source_env
        source test_source_env/bin/activate
        pip install --upgrade pip

        pip install --no-binary=confopt --index-url https://test.pypi.org/simple/ --extra-index-url https://pypi.org/simple/ confopt==$VERSION

        python -c "
        import numpy as np
        from confopt.tuning import ConformalTuner
        from confopt.wrapping import IntRange, FloatRange

        # Minimal synthetic test
        def simple_objective(configuration):
            # Simple quadratic function with noise
            x, y = configuration['x'], configuration['y']
            return (x - 2)**2 + (y - 3)**2 + np.random.normal(0, 0.1)

        search_space = {
            'x': FloatRange(min_value=0.0, max_value=5.0),
            'y': FloatRange(min_value=0.0, max_value=5.0)
        }

        tuner = ConformalTuner(
            objective_function=simple_objective,
            search_space=search_space,
            minimize=True
        )

        tuner.tune(max_searches=50, n_random_searches=15, verbose=False)
        best_params = tuner.get_best_params()
        best_value = tuner.get_best_value()

        print('TestPyPI source installation and functionality test successful!')
        print(f'Best params: {best_params}')
        print(f'Best value: {best_value:.4f}')
        "

        deactivate
        rm -rf test_source_env

        echo "All TestPyPI installation scenarios validated successfully!"
  publish:
    name: Publish to PyPI
    runs-on: ubuntu-latest
    needs: [verify-testpypi]

    steps:
    - name: Download build artifacts
      uses: actions/download-artifact@v4
      with:
        name: python-package-distributions
        path: dist/

    - name: Publish to PyPI
      uses: pypa/gh-action-pypi-publish@release/v1
      with:
        password: ${{ secrets.PYPI_API_TOKEN }}

  release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [publish]
    permissions:
      contents: write

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download build artifacts
      uses: actions/download-artifact@v4
      with:
        name: python-package-distributions
        path: dist/

    - name: Create GitHub Release Draft
      uses: softprops/action-gh-release@v2
      with:
        tag_name: v${{ needs.version-check.outputs.version }}
        name: Release v${{ needs.version-check.outputs.version }}
        body: |
          ## Package Information
          - **Version**: ${{ needs.version-check.outputs.version }}
          - **PyPI**: https://pypi.org/project/confopt/${{ needs.version-check.outputs.version }}/

          ## Changes
          *Please add release notes and changelog information here before publishing.*

          ---

          **Build Information:**
          - Commit: ${{ github.sha }}
          - PR: #${{ needs.check-package-label.outputs.pr_number != '0' && format('#{0}', needs.check-package-label.outputs.pr_number) || 'Manual Release' }}
          - Trigger: ${{ needs.check-package-label.outputs.is_manual == 'true' && 'Manual' || 'PR Merge' }}
        files: dist/*
        draft: true
        prerelease: false
